<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>æ™ºèƒ½ç®¡é“æ°´åŠ›åˆ†æå¹³å°</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <style>
        /* ä¼˜åŒ–åçš„æ ·å¼ */
        body {
            font-family: 'Segoe UI', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f7fa;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }

        .calculator {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #mapContainer {
            height: 600px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .map-toolbar {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .pipe-layer {
            stroke-width: 5;
            stroke-linecap: round;
            animation: pipeFlow 2s infinite;
        }

        @keyframes pipeFlow {
            0% {
                stroke-dashoffset: 10;
            }

            100% {
                stroke-dashoffset: 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="calculator">
            <h2>ç®¡é“æ°´åŠ›è®¡ç®—å™¨</h2>

            <div class="input-group">
                <label>æµé‡å•ä½ï¼š</label>
                <select id="flowUnit" onchange="convertFlowUnit()">
                    <option value="L/s">å‡/ç§’ (L/s)</option>
                    <option value="m3/h">ç«‹æ–¹ç±³/å°æ—¶ (mÂ³/h)</option>
                </select>
            </div>

            <div class="input-group">
                <label>æµé‡å€¼ï¼š</label>
                <input type="number" id="flowValue" value="10" step="0.1" min="0">
            </div>

            <div class="input-group">
                <label>ç®¡æç±»å‹ï¼š</label>
                <select id="material"></select>
            </div>

            <div class="input-group">
                <label>ç®¡å¾„ (mm)ï¼š</label>
                <input type="number" id="diameter" value="100" min="0">
            </div>

            <div class="input-group">
                <label>ç®¡çº¿é•¿åº¦ (m)ï¼š</label>
                <input type="number" id="length" value="100" min="0">
                <button onclick="syncFromMap()" style="margin-top:5px;">ä»åœ°å›¾è·å–é•¿åº¦</button>
            </div>

            <button onclick="calculate()" style="width:100%;margin-top:15px;">å¼€å§‹è®¡ç®—</button>

            <!-- ç»“æœå±•ç¤º -->
            <div class="result-section" id="results">
                <h3>è®¡ç®—ç»“æœ</h3>
                <div id="basicResults"></div>
                <div id="costEstimation"></div>
                <div id="pumpRecommendation"></div>
            </div>
        </div>
        <div>
            <div class="map-toolbar">
                <button onclick="toggleDrawing()">ğŸ“ ç»˜åˆ¶ç®¡çº¿</button>
                <button onclick="clearMap()">ğŸ—‘ï¸ æ¸…é™¤</button>
            </div>
            <div id="mapContainer"></div>
            <div class="chart-container">
                <canvas id="lossChart"></canvas>
            </div>
        </div>
    </div>


    <script>
        // å¢å¼ºç‰ˆç³»ç»Ÿé…ç½®
        const MAP_CONFIG = {
            baseLayers: {
                "è¡—é“åœ°å›¾": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
                "å«æ˜Ÿå½±åƒ": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),
                "åœ°å½¢å›¾": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png')
            },
            initCenter: [35.0, 105.0],
            initZoom: 4
        };

        const MATERIALS = [
            { name: 'PVCç®¡', C: 150, color: '#2ecc71', price: { 50: 8, 100: 15, 150: 22 } },
            { name: 'PEç®¡', C: 145, color: '#3498db', price: { 50: 10, 100: 18, 150: 25 } },
            { name: 'é•€é”Œé’¢ç®¡', C: 120, color: '#e67e22', price: { 50: 25, 100: 45, 150: 65 } },
            { name: 'çƒå¢¨é“¸é“ç®¡', C: 140, color: '#9b59b6', price: { 50: 35, 100: 60, 150: 85 } }
        ];

        const PUMPS = [
            { model: 'ISG50-160', flow: 10, head: 32, power: 3 },
            { model: 'ISG65-200', flow: 30, head: 50, power: 7.5 },
            { model: 'ISG80-250', flow: 50, head: 80, power: 15 }
        ];
        // ç³»ç»ŸçŠ¶æ€
        let currentPipeline = {
            coordinates: [],
            polyline: null,
            segments: []
        };


        class PipelineSystem {
            constructor() {
                this.coordinates = [];
                this.polyline = null;
                this.metadata = {
                    diameter: 0,
                    material: null,
                    segments: []
                };
            }

            updateStyle(lossPerMeter) {
                if (!this.polyline) return;
                this.polyline.setStyle({
                    color: this.getColor(lossPerMeter),
                    weight: Math.min(lossPerMeter * 50 + 5, 20)
                });
            }

            getColor(loss) {
                return loss > 0.1 ? '#e74c3c' :
                    loss > 0.05 ? '#f1c40f' : '#2ecc71';
            }

            clear() {
                this.coordinates = [];
                if (this.polyline) {
                    map.removeLayer(this.polyline);
                    this.polyline = null;
                }
            }
        }

        class HydraulicCalculator {
            static calculate(params) {
                // å¢å¼ºè®¡ç®—é€»è¾‘
                const Q = params.flowUnit === 'm3/h' ? params.flowValue / 3.6 : params.flowValue;
                const D = params.diameter / 1000;
                return {
                    velocity: Q * 0.001 / (Math.PI * (D / 2) ** 2),
                    hf: (10.67 * (Q / 1000) ** 1.852 * params.length) /
                        (params.C ** 1.852 * D ** 4.871)
                };
            }
        }
        // æ ¸å¿ƒè®¡ç®—å‡½æ•°
        function calculate() {
            // è·å–è¾“å…¥å‚æ•°
            const flowValue = parseFloat(document.getElementById('flowValue').value);
            const flowUnit = document.getElementById('flowUnit').value;
            const diameter = parseFloat(document.getElementById('diameter').value);
            const length = parseFloat(document.getElementById('length').value);
            const C = parseInt(document.getElementById('material').value);

            // å•ä½è½¬æ¢
            const Q = flowUnit === 'm3/h' ? flowValue / 3.6 : flowValue;

            // è®¡ç®—æ°´å¤´æŸå¤±
            const D = diameter / 1000;
            const area = Math.PI * (D / 2) ** 2;
            const velocity = Q * 0.001 / area;
            const hf = (10.67 * (Q / 1000) ** 1.852 * length) / (C ** 1.852 * D ** 4.871);

            // æ›´æ–°æ˜¾ç¤ºç»“æœ
            showResults(velocity, hf);
            updateChart(hf);
            updatePipelineStyle(hf / length);
            showCostEstimation(diameter, length);
            recommendPump(Q * 3.6, hf);
        }

        // ç»“æœå±•ç¤ºå‡½æ•°
        function showResults(v, hf) {
            const results = `
                <p>æµé€Ÿï¼š${v.toFixed(2)} m/s</p>
                <p>æ²¿ç¨‹æ°´å¤´æŸå¤±ï¼š${hf.toFixed(2)} m</p>
                ${v > 1.5 ? '<p class="warning">è­¦å‘Šï¼šæµé€Ÿè¶…è¿‡å®‰å…¨é˜ˆå€¼ï¼</p>' : ''}
            `;
            document.getElementById('basicResults').innerHTML = results;
        }

        function updateChart(hf) {
            const ctx = document.getElementById('lossChart').getContext('2d');
            if (chartInstance) chartInstance.destroy();

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({ length: 11 }, (_, i) => i * 10),
                    datasets: [{
                        label: 'æ²¿ç¨‹æ°´å¤´æŸå¤±åˆ†å¸ƒ',
                        data: Array.from({ length: 11 }, (_, i) => hf * (i / 10)),
                        borderColor: '#3498db',
                        tension: 0.1
                    }]
                }
            });
        }

        function updatePipelineStyle(lossPerMeter) {
            const material = MATERIALS.find(m => m.C === parseInt(document.getElementById('material').value));
            currentPipeline.polyline.setStyle({
                color: getColor(lossPerMeter),
                weight: lossPerMeter * 50 + 5
            });
        }

        function getColor(loss) {
            return loss > 0.1 ? '#e74c3c' :
                loss > 0.05 ? '#f1c40f' : '#2ecc71';
        }
        let map, chartInstance;
        let isDrawing = false;
        let pipelineSystem = new PipelineSystem();

        function initMaterials() {
            const materialSelect = document.getElementById('material');
            MATERIALS.forEach(m => {
                const option = document.createElement('option');
                option.value = m.C;
                option.textContent = m.name;
                materialSelect.appendChild(option);
            });
        }

        function initSystem() {
            // æå‰éªŒè¯å…³é”®DOMå…ƒç´ 
            const requiredElements = ['length', 'material', 'flowValue'];
            requiredElements.forEach(id => {
                if (!document.getElementById(id)) {
                    throw new Error(`æ— æ³•æ‰¾åˆ°å¿…éœ€çš„å…ƒç´  #${id}`);
                }
            });

            initMaterials();
            // åˆå§‹åŒ–åœ°å›¾
            map = L.map('mapContainer', {
                center: MAP_CONFIG.initCenter,
                zoom: MAP_CONFIG.initZoom
            });

            // æ·»åŠ å›¾å±‚æ§åˆ¶
            L.control.layers(MAP_CONFIG.baseLayers).addTo(map);
            MAP_CONFIG.baseLayers["å«æ˜Ÿå½±åƒ"].addTo(map);

            // ç»‘å®šäº‹ä»¶
            map.on('click', handleMapClick);
            // ç»‘å®šåœ°å›¾äº‹ä»¶
            map.on('click', addPipelinePoint);
        }
        // åœ°å›¾æ“ä½œå‡½æ•°
        function addPipelinePoint(e) {
            currentPipeline.coordinates.push(e.latlng);
            updatePipelineDisplay();
        }

        function updatePipelineDisplay() {
            if (currentPipeline.polyline) map.removeLayer(currentPipeline.polyline);
            currentPipeline.polyline = L.polyline(currentPipeline.coordinates, {
                color: '#3498db',
                weight: 5
            }).addTo(map);

            // æ›´æ–°é•¿åº¦è¾“å…¥
            document.getElementById('length').value = calculatePipelineLength();
        }
        // æ–°å¢é•¿åº¦æ›´æ–°å‡½æ•°
        function updateLengthInput() {
            const length = calculatePipelineLength();
            const lengthInput = document.getElementById('length');
            if (lengthInput) {
                lengthInput.value = length;
            }
        }

        // å®Œå–„ç®¡çº¿é•¿åº¦è®¡ç®—å‡½æ•°
        function calculatePipelineLength() {
            if (pipelineSystem.coordinates.length < 2) return 0;

            return pipelineSystem.coordinates.reduce((total, point, index, arr) => {
                return index > 0 ?
                    total + map.distance(arr[index - 1], point) :
                    total;
            }, 0).toFixed(1);
        }

        function handleMapClick(e) {
            if (!isDrawing) return;

            pipelineSystem.coordinates.push(e.latlng);
            updatePipelineDisplay();
            updateLengthInput();
        }

        function updatePipelineDisplay() {
            if (pipelineSystem.polyline) {
                map.removeLayer(pipelineSystem.polyline);
            }

            pipelineSystem.polyline = L.polyline(pipelineSystem.coordinates, {
                className: 'pipe-layer'
            }).addTo(map);
        }

        function toggleDrawing() {
            isDrawing = !isDrawing;
            map.getContainer().style.cursor = isDrawing ? 'crosshair' : '';
            if (!isDrawing) performCalculation();
        }

        function performCalculation() {
            const params = getInputParams();
            const results = HydraulicCalculator.calculate(params);

            // æ›´æ–°æ‰€æœ‰å¯è§†åŒ–ç»„ä»¶
            updateResultsDisplay(results);
            updateChart(results.hf);
            pipelineSystem.updateStyle(results.hf / params.length);
            showCostEstimation(params);
            recommendPump(params);
        }

        function getInputParams() {
            const flowValue = parseFloat(document.getElementById('flowValue').value);
            const flowUnit = document.getElementById('flowUnit').value;
            const diameter = parseFloat(document.getElementById('diameter').value);
            const length = parseFloat(document.getElementById('length').value);
            const C = parseInt(document.getElementById('material').value);
            return { flowValue, flowUnit, diameter, length, C };
        }

        function updateResultsDisplay(results) {
            const v = results.velocity;
            const hf = results.hf;
            const resultsHTML = `
                <p>æµé€Ÿï¼š${v.toFixed(2)} m/s</p>
                <p>æ²¿ç¨‹æ°´å¤´æŸå¤±ï¼š${hf.toFixed(2)} m</p>
                ${v > 1.5 ? '<p class="warning">è­¦å‘Šï¼šæµé€Ÿè¶…è¿‡å®‰å…¨é˜ˆå€¼ï¼</p>' : ''}
            `;
            document.getElementById('basicResults').innerHTML = resultsHTML;
        }

        function updateChart(hf) {
            const ctx = document.getElementById('lossChart').getContext('2d');
            if (chartInstance) chartInstance.destroy();

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({ length: 11 }, (_, i) => i * 10),
                    datasets: [{
                        label: 'æ²¿ç¨‹æ°´å¤´æŸå¤±åˆ†å¸ƒ',
                        data: Array.from({ length: 11 }, (_, i) => hf * (i / 10)),
                        borderColor: '#3498db',
                        tension: 0.1
                    }]
                }
            });
        }

        function showCostEstimation(params) {
            const material = MATERIALS.find(m => m.C === params.C);
            const price = material.price[params.diameter] || material.price[Object.keys(material.price)[0]];
            const cost = `
                <h4>æˆæœ¬ä¼°ç®—</h4>
                <p>å•ä»·ï¼šÂ¥${price}/ç±³</p>
                <p>æ€»æˆæœ¬ï¼šÂ¥${(price * params.length).toLocaleString()}</p>
            `;
            document.getElementById('costEstimation').innerHTML = cost;
        }

        function recommendPump(params) {
            const Q = params.flowUnit === 'm3/h' ? params.flowValue : params.flowValue * 3.6;
            const hf = (10.67 * (params.flowValue / 1000) ** 1.852 * params.length) /
                (params.C ** 1.852 * (params.diameter / 1000) ** 4.871);
            const suitablePumps = PUMPS.filter(p => p.flow >= Q && p.head >= hf * 1.1);
            const recommendation = suitablePumps.length > 0 ?
                suitablePumps[0] : PUMPS[PUMPS.length - 1];

            const pumpInfo = `
                <h4>æ°´æ³µæ¨è</h4>
                <p>å‹å·ï¼š${recommendation.model}</p>
                <p>æµé‡ï¼š${recommendation.flow} mÂ³/h</p>
                <p>æ‰¬ç¨‹ï¼š${recommendation.head} m</p>
                <p>åŠŸç‡ï¼š${recommendation.power} kW</p>
            `;
            document.getElementById('pumpRecommendation').innerHTML = pumpInfo;
        }

        function clearMap() {
            try {
                // æ¸…é™¤åœ°å›¾ç»˜åˆ¶
                pipelineSystem.clear();

                // æ¸…ç©ºé•¿åº¦è¾“å…¥
                document.getElementById('length').value = '';

                // é‡ç½®è®¡ç®—ç»“æœ
                document.getElementById('basicResults').innerHTML = '';
                document.getElementById('costEstimation').innerHTML = '';
                document.getElementById('pumpRecommendation').innerHTML = '';

                // é‡ç½®å›¾è¡¨
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }

                console.log('åœ°å›¾å·²é‡ç½®');
            } catch (error) {
                console.error('æ¸…é™¤åœ°å›¾å¤±è´¥:', error);
                alert('æ¸…é™¤æ“ä½œå‡ºç°å¼‚å¸¸ï¼Œè¯·åˆ·æ–°é¡µé¢');
            }
        }

        function syncFromMap() {
            try {
                const length = calculatePipelineLength();
                document.getElementById('length').value = length;
            } catch (error) {
                console.error("åŒæ­¥åœ°å›¾é•¿åº¦å¤±è´¥:", error);
                alert("æ— æ³•è·å–é•¿åº¦ï¼Œè¯·å…ˆç»˜åˆ¶ç®¡çº¿ï¼");
            }
        }

        function convertFlowUnit() {
            const currentValue = parseFloat(document.getElementById('flowValue').value);
            const unit = document.getElementById('flowUnit').value;

            if (unit === 'm3/h') {
                document.getElementById('flowValue').value = currentValue ? currentValue * 3.6 : '';
            } else {
                document.getElementById('flowValue').value = currentValue ? currentValue / 3.6 : '';
            }
        }

        window.onload = initSystem;
    </script>
</body>

</html>