<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸“ä¸šç®¡é“æ°´åŠ›è®¡ç®—å·¥å…· | å·¥ç¨‹æµä½“åŠ›å­¦è§£å†³æ–¹æ¡ˆ</title>
    <style>
        :root {
            --primary: #3a86ff;
            --primary-light: #8bb8ff;
            --secondary: #8338ec;
            --dark: #212529;
            --light: #f8f9fa;
            --gray: #6c757d;
            --glass-bg: rgba(255, 255, 255, 0.15);
            --glass-border: rgba(255, 255, 255, 0.2);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            --transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            min-height: 100vh;
            padding-bottom: 60px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            padding: 60px 0 40px;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--gray);
            max-width: 700px;
            margin: 0 auto;
        }
        .custom-input {
            width: 80%;
            height: 48px;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            padding: 30px;
            transition: var(--transition);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }
        .card:nth-child(4) { animation-delay: 0.4s; }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .card-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            color: white;
            font-size: 24px;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: var(--dark);
        }

        h3 {
            font-size: 1.2rem;
            margin: 25px 0 15px;
            color: var(--dark);
            position: relative;
            padding-left: 15px;
        }

        h3::before {
            content: '';
            position: absolute;
            left: 0;
            top: 5px;
            height: 70%;
            width: 4px;
            background: linear-gradient(to bottom, var(--primary), var(--secondary));
            border-radius: 2px;
        }

        p {
            margin-bottom: 15px;
            color: var(--dark);
        }

        ul, ol {
            margin-bottom: 20px;
            padding-left: 20px;
        }

        li {
            margin-bottom: 8px;
            position: relative;
        }

        li::before {
            content: 'â€¢';
            color: var(--primary);
            font-weight: bold;
            display: inline-block;
            width: 1em;
            margin-left: -1em;
        }

        .highlight {
            background-color: rgba(58, 134, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--glass-bg);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--glass-border);
        }

        th {
            background-color: rgba(58, 134, 255, 0.1);
            font-weight: 600;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .btn {
            display: inline-block;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            margin-top: 20px;
            transition: var(--transition);
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(58, 134, 255, 0.4);
        }

        .footer {
            text-align: center;
            margin-top: 60px;
            color: var(--gray);
            font-size: 0.9rem;
        }

        .footer a {
            color: var(--primary);
            text-decoration: none;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .card-grid {
                grid-template-columns: 1fr;
            }
            
            .card {
                padding: 20px;
            }
        }

        @media (max-width: 500px) {
            header {
                padding: 40px 0 30px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }
            
            .card-icon {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            h2 {
                font-size: 1.3rem;
            }
            
            h3 {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            
            <h2>
                ç®¡é“æ²¿ç¨‹æ°´å¤´æŸå¤±è®¡ç®—å™¨&nbsp;|&nbsp;ä¸“ä¸šæ°´åŠ›è®¡ç®—å·¥å…·
            </h2>
            <p class="subtitle">ä¸ºçŒæº‰å·¥ç¨‹ã€ç»™æ’æ°´ã€æš–é€šç­‰å·¥ç¨‹åœºæ™¯æä¾›ç²¾ç¡®çš„æµä½“åŠ›å­¦è®¡ç®—è§£å†³æ–¹æ¡ˆ</p>
        </header>

        <div class="card-grid">
            <div class="card">
                <div class="card-icon">âš™ï¸</div>
                <h2>æ ¸å¿ƒåŠŸèƒ½</h2>
                <h3>æ²¿ç¨‹æ°´å¤´æŸå¤±è®¡ç®—</h3>
                <p>æ”¯æŒé€šè¿‡è¾“å…¥ç®¡é“èŠ‚ç‚¹åæ ‡ã€æµé‡ã€å±€éƒ¨æŸå¤±ç³»æ•°ã€ç®¡æ®µç›´å¾„ç­‰å‚æ•°ï¼Œç»“åˆä¸åŒå…¬å¼è®¡ç®—æ°´åŠ›å‚æ•°ã€‚</p>
                <ul>
                    <li>è¾¾è¥¿-é­æ–¯å·´èµ«å…¬å¼</li>
                    <li>å“ˆæ£®-å¨å»‰å§†æ–¯å…¬å¼</li>
                    <li>å–·çŒè§„èŒƒå…¬å¼</li>
                    <li>å¾®çŒè§„èŒƒå…¬å¼</li>
                </ul>
            </div>

            <div class="card">
                <div class="card-icon">ğŸ“Š</div>
                <h2>æ“ä½œæµç¨‹</h2>
                <h3>æ•°æ®è¾“å…¥</h3>
                <p><strong>æ ¼å¼è¦æ±‚ï¼š</strong>æ¯è¡Œä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ•°æ®ä»¥è‹±æ–‡","åˆ†éš”ï¼Œä¾‹å¦‚ï¼š<span class="highlight">0,0,0,40,0.05,100</span></p>
                <p><strong>å‚æ•°èŒƒå›´ï¼š</strong></p>
                <ul>
                    <li>èŠ‚ç‚¹åæ ‡ï¼ˆå•ä½ï¼šmï¼‰</li>
                    <li>å‡ºæµé‡ï¼ˆå•ä½ï¼šmÂ³/hï¼‰</li>
                    <li>å±€éƒ¨æŸå¤±ç³»æ•°ï¼ˆ â€” ï¼‰</li>
                    <li>ç®¡æ®µç›´å¾„ï¼ˆå•ä½ï¼šmmï¼‰</li>
                </ul>
            </div>

            <div class="card">
                <div class="card-icon">ğŸ”</div>
                <h2>å…¬å¼é€‰æ‹©</h2>
                <h3>è¾¾è¥¿-é­æ–¯å·´èµ«å…¬å¼</h3>
                <p>éœ€è¡¥å……æµä½“å¯†åº¦ï¼ˆkg/mÂ³ï¼‰ã€ç²˜åº¦ï¼ˆPaÂ·sï¼‰ã€ç®¡é“ç²—ç³™åº¦ï¼ˆmmï¼‰ã€‚</p>
                <h3>å“ˆæ£®-å¨å»‰å§†æ–¯å…¬å¼</h3>
                <p>éœ€è¾“å…¥Cç³»æ•°ã€‚</p>
            </div>

            <div class="card">
                <div class="card-icon">ğŸ“</div>
                <h2>å‚æ•°è®¾ç½®</h2>
                <p><strong>å¿…å¡«å‚æ•°ï¼š</strong></p>
                <ul>
                    <li>ä¸»ç®¡å†…å¾„ï¼ˆmmï¼‰</li>
                    <li>æ€»æ°´å¤´/æ°´æ³µæ‰¬ç¨‹ï¼ˆmï¼‰</li>
                </ul>
                <h3>ç®¡é“ç²—ç³™åº¦å‚è€ƒå€¼</h3>
                <table>
                    <thead>
                        <tr>
                            <th>æè´¨</th>
                            <th>ç²—ç³™åº¦èŒƒå›´ï¼ˆmmï¼‰</th>
                            <th>å…¸å‹å–å€¼ï¼ˆmmï¼‰</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>å¡‘æ–™ç®¡</td>
                            <td>0.0015~0.01</td>
                            <td>150</td>
                        </tr>
                        <tr>
                            <td>æ–°é“¸é“ç®¡</td>
                            <td>-</td>
                            <td>130</td>
                        </tr>
                        <tr>
                            <td>æ—§é’¢ç®¡</td>
                            <td>1~2</td>
                            <td>100</td>
                        </tr>
                        <tr>
                            <td>æ··å‡åœŸç®¡</td>
                            <td>0.3~3</td>
                            <td>120</td>
                        </tr>
                        <tr>
                            <td>çŸ³æ£‰æ°´æ³¥ç®¡</td>
                            <td>0.03~0.15</td>
                            <td>130~140</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="card" style="margin-top: 40px;">
            <div class="card-icon">â„¹ï¸</div>
            <h2>å…³é”®æ¦‚å¿µä¸æ³¨æ„äº‹é¡¹</h2>
            <h3>å±€éƒ¨é˜»åŠ›ç³»æ•°ï¼ˆkï¼‰</h3>
            <p>æ— é‡çº²æ•°ï¼Œåæ˜ æµä½“æµç»ç®¡é“é™„ä»¶ï¼ˆå¦‚å¼¯å¤´ã€é˜€é—¨ï¼‰æ—¶çš„èƒ½é‡æŸå¤±ã€‚</p>
            <p><strong>å–å€¼ä¾æ®ï¼š</strong>æµä½“æ–¹å‘å˜åŒ–ã€é€Ÿåº¦å˜åŒ–ï¼Œéœ€å‚è€ƒæ°´åˆ©å­¦æ‰‹å†Œæˆ–å®éªŒæ•°æ®ã€‚</p>

            <h3>æ³¨æ„äº‹é¡¹</h3>
            <ul>
                <li><strong>æ•°æ®å‡†ç¡®æ€§ï¼š</strong>ä¸¥æ ¼éµå¾ªè¾“å…¥æ ¼å¼ï¼Œé¿å…å› æ ¼å¼é”™è¯¯å¯¼è‡´è®¡ç®—åå·®ã€‚</li>
                <li><strong>å…¬å¼é€‚ç”¨æ€§ï¼š</strong>è¾¾è¥¿-é­æ–¯å·´èµ«å…¬å¼é€‚ç”¨äºç²¾ç¡®æµä½“å‚æ•°å·²çŸ¥çš„åœºæ™¯ï¼›å“ˆæ£®-å¨å»‰å§†æ–¯å…¬å¼æ›´ä¾èµ–ç»éªŒç³»æ•°Cã€‚</li>
                <li><strong>å·¥ç¨‹å®è·µå»ºè®®ï¼š</strong>ä¼˜å…ˆä½¿ç”¨å®æµ‹ç²—ç³™åº¦ä¸é˜»åŠ›ç³»æ•°ï¼Œå¤æ‚é—®é¢˜éœ€ç»“åˆä¸“ä¸šç»éªŒéªŒè¯è®¡ç®—ç»“æœã€‚</li>
            </ul>

            <a href="https://www.irripro.com.cn/Head_Loss_Calculator_Used.html" class="btn">è®¿é—®å·¥å…·</a>
        </div>

        <div class="footer">
            <p>ç½‘é¡µç”±IrriProè®¾è®¡</p>
            <p>æœ€åæ›´æ–°æ—¶é—´ä¸º2025-04-19ï¼Œæ˜ŸæœŸå…­</p>
            <p><a href="https://www.irripro.com.cn" target="_blank">çŒæº‰å¤§å¸ˆ</a></p>
        </div>
    </div>

    <script>
        // ç®€å•çš„æ»šåŠ¨åŠ¨ç”»è§¦å‘
        document.addEventListener('DOMContentLoaded', function() {
            const cards = document.querySelectorAll('.card');
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.animation = `fadeInUp 0.6s forwards ${entry.target.dataset.delay || '0s'}`;
                        observer.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.1
            });

            cards.forEach((card, index) => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                card.dataset.delay = `${index * 0.1}s`;
                observer.observe(card);
            });
        });
    </script>



  <!-- <div class="jz_fix_ue_img"> -->
      <!-- <p style="line-height:1.5em;"> -->
          <!-- <span style="color:rgba(0, 0, 0, 0.9);font-family:mp-quote, -apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;font-size:17px;text-align:justify;text-wrap:wrap;"><img src="//10446153.s21i.faiusr.com/4/ABUIABAEGAAgla-xuAYoqq-rzgUw-wU4gQc.png" width="767" alt="20241026" /></span> -->
      <!-- </p> -->

      <style>body { font-family: Arial, sans-serif; }
    .container { max-width: 900px; margin: 20px auto; padding: 20px; border: 1px solid #ccc; border-radius: 5px; }
    textarea, select, input[type="number"], button { display: block; width: 100%; margin: 10px 0; }
    .result { margin-top: 20px; }</style>

<div class="container">
  <h2>ç®¡é“æ²¿ç¨‹æ°´å¤´æŸå¤±è®¡ç®—å™¨</h2>
 
  <p>è¯·è¾“å…¥ç®¡é“èŠ‚ç‚¹åæ ‡ã€æµé‡åŠå±€éƒ¨æŸå¤±ç³»æ•° (æ¯è¡Œä¸€ä¸ªèŠ‚ç‚¹åæ ‡ x,y,zï¼ˆmï¼‰, èŠ‚ç‚¹å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼Œè¯·ä½¿ç”¨è‹±æ–‡â€œ,â€åˆ†éš”æ•°æ®ã€‚ä¾‹å¦‚: 0,0,0,40,0.05,100)ï¼š</p>
  <p>
    å±€éƒ¨é˜»åŠ›ç³»æ•°ç»¼åˆè€ƒè™‘äº†å½¢çŠ¶å› ç´ ã€‚åœ¨å…·ä½“åº”ç”¨ä¸­ï¼Œkå€¼å¯èƒ½éœ€è¦å‚è€ƒç›¸å…³æ°´åˆ©å­¦æ‰‹å†Œæˆ–é€šè¿‡å®éªŒç¡®å®šã€‚
  </p>
  <textarea id="coordinates" rows="10">
  0,0,0,0,0.01,100
  10,0,10,40,0.05,100
  10,20,10,40,0.05,100
  100,20,20,40,0.05,100
  200,100,20,40,0.05,100
  </textarea>
  <p><h3>è¯·é€‰æ‹©æ°´å¤´æŸå¤±è®¡ç®—å…¬å¼ï¼š</h3></p>
  <select id="formula">
    <!-- <option value="darcy-weisbach">è¾¾è¥¿-é­æ–¯å·´èµ« darcy-weisbach</option> -->
    <option value="hazen-williams">å“ˆæ£®-å¨å»‰å§†æ–¯ hazen-williams</option>
    <option value="sprinkler-irrigation">å–·çŒè§„èŒƒ sprinkler-irrigation</option>
    <option value="micro-irrigation">å¾®çŒè§„èŒƒ micro-irrigation</option>
  </select>
  <p><h3>ä¸»ç®¡ç®¡é“å†…å¾„ (mm)ï¼š</h3></p>
  <input type="number" id="diameter" value="100" step="1" required class="custom-input">
  <p><h3>ä¸»ç®¡æ€»æ°´å¤´/æ°´æ³µæ‰¬ç¨‹ (m)ï¼š</h3></p>
  <input type="number" id="totalHead" value="60" step="1" required class="custom-input">
  <p><h3>æµä½“ç²˜åº¦ (PaÂ·s) ï¼š</h3></p>
  <input type="number" id="viscosity" value="0.001" step="0.0001" class="custom-input">
  
  <p>1. å¡‘æ–™<br>
    ~ å¡‘æ–™ç®¡é“ï¼ˆå¦‚PVCç®¡ç­‰ï¼‰çš„ç²—ç³™åº¦ç›¸å¯¹è¾ƒå°ã€‚å¯¹äºå…‰æ»‘çš„å¡‘æ–™ç®¡é“ï¼Œå…¶ç­‰æ•ˆç²—ç³™åº¦å€¼é€šå¸¸åœ¨(0.0015 ~ 0.01)mmä¹‹é—´ã€‚åœ¨æ°´åŠ›è®¡ç®—ä¸­ï¼Œè¿™ç§è¾ƒå°çš„ç²—ç³™åº¦ä½¿å¾—å¡‘æ–™ç®¡é“åœ¨ç›¸åŒæµé‡ä¸‹äº§ç”Ÿçš„æ²¿ç¨‹æ°´å¤´æŸå¤±ç›¸å¯¹è¾ƒå°ã€‚
    <br>2. é’¢é“<br>
    ~ æ–°çš„ã€å…‰æ»‘çš„é’¢ç®¡ç²—ç³™åº¦å€¼çº¦ä¸º(0.046 ~ 0.1)mmã€‚ä½†éšç€ä½¿ç”¨æ—¶é—´çš„å¢åŠ ï¼Œç”±äºè…èš€ã€ç»“å¢ç­‰åŸå› ï¼Œç²—ç³™åº¦å¯èƒ½ä¼šæ˜¾è‘—å¢åŠ ã€‚ä¾‹å¦‚ï¼Œæ—§é’¢ç®¡çš„ç²—ç³™åº¦å¯èƒ½è¾¾åˆ°(1 ~ 2)mmç”šè‡³æ›´é«˜ã€‚åœ¨æ°´åŠ›è®¡ç®—æ—¶ï¼Œç²—ç³™åº¦çš„å˜åŒ–ä¼šå¯¹æ²¿ç¨‹æ°´å¤´æŸå¤±çš„è®¡ç®—ç»“æœäº§ç”Ÿå¾ˆå¤§å½±å“ã€‚
    <br>3. ç ¼ï¼ˆæ··å‡åœŸï¼‰<br>
    ~ æ™®é€šæ··å‡åœŸç®¡é“çš„ç²—ç³™åº¦å€¼å¤§çº¦åœ¨(0.3 ~ 3)mmä¹‹é—´ã€‚å¦‚æœæ··å‡åœŸè¡¨é¢å¤„ç†è¾ƒä¸ºç²—ç³™å€¼ä¼šåå‘è¾ƒå¤§å€¼ï¼›å¦‚æœè¿›è¡Œäº†è¾ƒä¸ºç²¾ç»†çš„æŠ¹é¢ç­‰å¤„ç†ï¼Œ(roughness)å€¼å¯èƒ½ä¼šæ¥è¿‘(0.3)mmã€‚è¿™ä¸€ç²—ç³™åº¦å€¼åœ¨æ°´åŠ›è®¡ç®—ä¸­å¯¹ç¡®å®šæ··å‡åœŸç®¡é“çš„è¾“æ°´èƒ½åŠ›å’Œæ°´å¤´æŸå¤±èµ·ç€é‡è¦ä½œç”¨ã€‚
    <br>4. çŸ³æ£‰<br>
    ~ çŸ³æ£‰æ°´æ³¥ç®¡çš„ç²—ç³™åº¦å€¼å¤§æ¦‚åœ¨(0.03 ~ 0.15)mmèŒƒå›´å†…ã€‚åœ¨æ°´åŠ›è®¡ç®—æ—¶ï¼Œéœ€è¦æ ¹æ®çŸ³æ£‰æ°´æ³¥ç®¡çš„å®é™…ç”Ÿäº§å·¥è‰ºå’Œä½¿ç”¨çŠ¶å†µç¡®å®šå…¶ç²—ç³™åº¦å–å€¼ï¼Œä»¥å‡†ç¡®è®¡ç®—æ²¿ç¨‹æ°´å¤´æŸå¤±ç­‰æ°´åŠ›å‚æ•°ã€‚</p>
  <p><h3>ç®¡é“ç²—ç³™åº¦ (mm) ï¼š</h3></p>
  
  <input type="number" id="roughness" value="0.002" step="0.1"class="custom-input"   class="custom-input">
  <p><h3>20 â„ƒ æµä½“å¯†åº¦ (kg/mÂ³) ï¼š</h3></p>
 <input type="number" id="density" value="1000" step="10">
  <!-- <p><h3>æµé‡ (mÂ³/h)ï¼š</h3></p>
  <input type="number" id="flowRate" value="40" step="any" required> -->
  <!-- 
  <p><h3>æµä½“ç²˜åº¦ (PaÂ·s) [ä»…ç”¨äºè¾¾è¥¿-é­æ–¯å·´èµ«]ï¼š</h3></p>
  
  -->
 
  <p>å¡‘æ–™ç®¡ï¼ˆå¦‚PVC, PE, PPç­‰ï¼‰: é€šå¸¸å–å€¼ä¸º 150<br>
    æ–°é“¸é“ç®¡: é€šå¸¸å–å€¼ä¸º 130<br>
    æ—§é“¸é“ç®¡å’Œæ—§é’¢ç®¡: é€šå¸¸å–å€¼ä¸º 100<br>
    æ··å‡åœŸç®¡ï¼ˆç ¼ï¼‰: é€šå¸¸å–å€¼ä¸º 120<br>
    çŸ³æ£‰æ°´æ³¥ç®¡: é€šå¸¸å–å€¼ä¸º 130 åˆ° 140 ä¹‹é—´ï¼Œå…·ä½“å–å†³äºç®¡é“çš„æ–°æ—§ç¨‹åº¦å’Œè¡¨é¢çŠ¶å†µã€‚</p> 
  <p><h3>Cç³»æ•° [ä»…ç”¨äºå“ˆæ£®-å¨å»‰å§†æ–¯ï¼š</h3></p>
  <input type="number" id="cFactor" value="140" step="10">
  <button onclick="calculate()"><h2>è®¡ç®—</h2></button>
  
  <div class="piperesult" id="piperesult"></div>
 
  <div class="headlossresult" id="headlossresult"></div>
  <p ></p>

  <div class="result" id="result"></div>
  
  <canvas id="PipelineChart" width="1024" height="400"></canvas>
  <canvas id="headLossChart" width="1024" height="400"></canvas>
  <canvas id="chartContainer" width="1024" height="400"></canvas>
</div>
  <!-- å¼•å…¥ Chart.js UMD ç‰ˆæœ¬ -->
   <script src="https://unpkg.com/chart.js@4.4.4/dist/chart.umd.js"></script>
  <!-- <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.js" crossorigin="anonymous"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
<!-- src="calculator.js" -->
<script >
     
    const gravity = 9.81; // é‡åŠ›åŠ é€Ÿåº¦
    // ä¿å­˜å¯¹ Chart.js å®ä¾‹çš„å¼•ç”¨ chart1Instance
    let chartInstance = null;
    let chart1Instance = null;
    let chartpipelineInstance = null;

    function calculateDarcyWeisbach( frictionFactor, pipeLength, pipeDiameter, fluidVelocity) {
        const gravity = 9.81; // é‡åŠ›åŠ é€Ÿåº¦ (m/s^2)
        
        // è®¡ç®—æ‘©æ“¦å¼•èµ·çš„å‹åŠ›å¤´æŸå¤±
        headLoss = frictionFactor * (pipeLength / pipeDiameter) * (Math.pow(fluidVelocity, 2) / (2 * gravity));
        
        return headLoss;
    }
    function calculateFrictionFactor(roughness, diameter, reynolds) {
        let f = 0.01; // åˆå§‹çŒœæµ‹å€¼
        let error = 1e-6; // å®šä¹‰è¯¯å·®å®¹å¿åº¦
        let iterations = 0;
        let maxIterations = 1000;
        if (roughness === 0) { // å‡è®¾å…‰æ»‘ç®¡
            f = 0.079 * Math.pow(reynolds, -0.25);
            } 
        if (reynolds < 2300) { // å±‚æµ
            f = 64 / reynolds;
        } else if (reynolds > 4000) { // æ¹æµ
             // ç²—ç³™ç®¡
            const epsilonOverD = roughness / diameter;
            f = 1 / (2 * Math.log10(epsilonOverD / 3.7 + 2.51 / reynolds)) ** 2;
            // const epsilonOverD = roughness / diameter;
            
        }else{
            while (iterations < maxIterations) {
                let f1 = -2 * Math.log10((roughness / (3.7 * diameter)) + (2.51 / (reynolds * Math.sqrt(f))));
                let df = f1 - f;
                f = f1;
                
                if (Math.abs(df) < error) {
                    break;
                }
                
                iterations++;
            }
        }
        return f;
    }


    // æ›´æ–°å›¾è¡¨ cumulativeHeadLossï¼Œ totalLength
    function updateChart(nodes, cumulativeHeadLoss, PipeLength) {
        const chartCanvas = document.getElementById('chartContainer');
        const ctx = chartCanvas.getContext('2d');

        // é”€æ¯ä¹‹å‰çš„å›¾è¡¨å®ä¾‹
        if (chartInstance) {
            chartInstance.destroy();
        }

        // ä» nodes æ•°ç»„ä¸­ç§»é™¤ç¬¬ä¸€ä¸ªå…ƒç´ 
        // nodes.shift();

        // åˆ›å»ºæ–°çš„å›¾è¡¨å®ä¾‹
        chartInstance = new Chart(ctx, {
            type: 'scatter',
            data: {
                labels: 'æ°´å¤´é«˜åº¦ (m)', // èŠ‚ç‚¹æ ‡ç­¾
                datasets: [{
                    label: ' æ°´å¤´æŸå¤± (m)',
                    data: cumulativeHeadLoss.map((value, index) => ({
                        x: PipeLength[index],
                        y: value //-nodes[index].z
                    })),
                    showLine: true,
                    fill: true,
                    borderColor: 'rgb(75, 94, 232)',
                    // fillColor: 'rgb(75, 94, 222)',
                    borderWidth: 3, // çº¿æ¡å®½åº¦
                    borderDash: [16, 3,4,3], // è™šçº¿æ¨¡å¼ï¼Œæ•°ç»„ç¬¬ä¸€é¡¹æ˜¯ dash çš„é•¿åº¦ï¼Œç¬¬äºŒé¡¹æ˜¯ gap çš„é•¿åº¦
                    backgroundColor: 'rgba(75, 192, 192, 0.2)', // æ•°æ®ç‚¹èƒŒæ™¯è‰²ï¼ˆå¦‚æœéœ€è¦ï¼‰
                    pointBorderColor: 'rgba(75, 192, 192, 1)', // æ•°æ®ç‚¹è¾¹æ¡†é¢œè‰²
                    pointBackgroundColor: '#fff', // æ•°æ®ç‚¹èƒŒæ™¯è‰²
                    tension: 0.2
                },
                // {
                //     label: '', // è¿™ä¸ªæ ‡ç­¾å¯ä»¥éšè— è¾…åŠ©æ•°æ® (ä»…ç”¨äºå¡«å……)
                //     data: cumulativeHeadLoss.map((y, index) => ({ x: PipeLength[index], y: y-nodes[index].z })),
                //     fill: 'bottom', // æˆ–è€…ä½¿ç”¨'bottom'/'top'æ ¹æ®éœ€è¦origin
                //     backgroundColor: 'rgba(75, 94, 222, 0.2)', // è¾…åŠ©å¡«å……çš„é¢œè‰²å’Œé€æ˜åº¦
                //     borderColor: 'transparent', // è¾¹æ¡†é¢œè‰²è®¾ç½®ä¸ºé€æ˜
                //     pointRadius: 5, // ä¸æ˜¾ç¤ºæ•°æ®ç‚¹
                //     showLine: true, // ä¸æ˜¾ç¤ºè¾…åŠ©çº¿
                // },
            ]
            },
            options: {
              scales: {
                  x: {
                      title: {
                          display: true,
                          text: 'ç®¡é“é•¿åº¦ (m)'
                      },
                      beginAtZero: true,
                      type: 'linear',
                      position: 'bottom'
                  },
                  y: {
                      title: {
                          display: true,
                          text: 'æ€»æ°´å¤´çº¿ (m)'
                      },
                      beginAtZero: true,
                      type: 'linear',
                      position: 'left'
                  }
              }
          }
        });
    }

    function calculateAndPlot(pipeLengths,totalHeadlines,nodes) {
    // const frictionFactor = parseFloat(document.getElementById('frictionFactor').value);
    // const pipeLength = parseFloat(document.getElementById('pipeLength').value);
    // const flowRate = parseFloat(document.getElementById('flowRate').value);
    // const pipeDiameter = parseFloat(document.getElementById('pipeDiameter').value);

    // const headLoss = calculateHeadLoss(frictionFactor, pipeLength, flowRate, pipeDiameter);
    
    
    // ç»˜åˆ¶å›¾è¡¨
    const ctx = document.getElementById('headLossChart').getContext('2d');
    if (chart1Instance) {
        chart1Instance.destroy();
    }
    // åè½¬æ•°ç»„
    //var reversedHeadLoss = totalHeadlines.slice().reverse(); // ä½¿ç”¨ slice() åˆ›å»ºå‰¯æœ¬ä»¥é¿å…ä¿®æ”¹åŸæ•°ç»„
    //é‡å†™å…¥æ•°ç»„
    //var pipeL=[];
    //pipeL.push(0);
    //for(i=headLoss.length;i>0;i--){
      //pipeL.push(pipeLengths[i]);

    //}
    chart1Instance =new Chart(ctx, {
        type: 'scatter',
        data: {
             //labels: ' æ²¿ç¨‹æ€»æ°´å¤´çº¿ (m)' ,[0,pipeLength ], //'L ${pipeLength[index].toFixed(2)} m}', // å‡è®¾åªå±•ç¤ºèµ·ç‚¹å’Œç»ˆç‚¹
            datasets: [{
                    label: ' æ²¿ç¨‹æ€»æ°´å¤´çº¿ (m)',
                    data: totalHeadlines.map((value, index) => ({
                        x: pipeLengths[index],
                        y: value
                    })),
                    showLine: true,
                    fill: false,
                    borderColor: 'red',
                    borderDash: [6,1, 6], 
                    lineTension: 0.1,
                    tension: 0.2
                }, 
                {
                    label: ' åœ°é¢é«˜ç¨‹z (m)',
                    data: nodes.map((value, index) => ({
                        x: pipeLengths[index],
                        y: value.z
                    })),
                    showLine: true,
                    fill: true,
                    borderColor: 'rgb(15, 230, 20)',
                    borderWidth: 3, // çº¿æ¡å®½åº¦
                    borderDash: [5, 5], // è™šçº¿æ¨¡å¼ï¼Œæ•°ç»„ç¬¬ä¸€é¡¹æ˜¯ dash çš„é•¿åº¦ï¼Œç¬¬äºŒé¡¹æ˜¯ gap çš„é•¿åº¦
                    backgroundColor: 'rgba(75, 192, 192, 0.2)', // æ•°æ®ç‚¹èƒŒæ™¯è‰²ï¼ˆå¦‚æœéœ€è¦ï¼‰
                    pointBorderColor: 'rgba(75, 192, 192, 1)', // æ•°æ®ç‚¹è¾¹æ¡†é¢œè‰²
                    pointBackgroundColor: '#fff', // æ•°æ®ç‚¹èƒŒæ™¯è‰²
                    tension: 0.1
                }],
        },
        options: {
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: ' æ°´å¤´çº¿ (m)'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: ' ç®¡é“çºµæ–­é¢ï¼ˆmï¼‰'
                    }
                }
            },
            plugins: {
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const { x, y } = context.parsed;
                                return `ï¼ˆH/Zï¼‰: ${y.toFixed(3)} m, Node:${x.toFixed(0)} `;
                            }
                        }
                    }
            }
        }
    
    }
    );
}
//pipeLengths,headLoss,
function plotPipeline (nodes) {
       
    
    // ç»˜åˆ¶å›¾è¡¨
    const ctx = document.getElementById('PipelineChart').getContext('2d');
    if (chartpipelineInstance) {
        chartpipelineInstance.destroy();
        }
    let showThisLine=false;
    
    chartpipelineInstance =new Chart(ctx, {
    // Assuming nodes contains objects like { x: number, y: number, q: number }

      type: 'scatter', // Use scatter for better control over individual points
      data: {
        datasets: [
          // First dataset remains unchanged
          {
            label: 'ç®¡é“å¹³é¢å¸ƒç½®å›¾',
            data: nodes.map(point => ({ x: point.x, y: point.y })),
            borderColor: 'blue',
            fill: false,
            showLine: true,
            pointRadius: 0,
            pointBackgroundColor: 'blue'
          },
          // Second dataset corrected
          {
            label: 'å‡ºæµ q',
            data: nodes.filter(point => point.q !== 0).flatMap(point => [
              { x: point.x, y: point.y }, // Original Point + 0.1 + point.q/40
              { x: point.x , y: point.y + point.q/50, q: point.q } // Additional Point
            ]),
            borderColor: 'red',
            backgroundColor: 'transparent',
            pointBorderWidth: 1,
            pointRadius: 4,
            
          }
        ]
      },
      options: {
        scales: {
          x: {
            type: 'linear',
            position: 'bottom' 
          },
          y: {
            type: 'linear',
            position: 'left'
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              label: (context) => {
                if ('q' in context.raw) {
                  return `q (mÂ³/h): ${context.raw.q}`; // x: ${context.parsed.x.toFixed(2)}, y: ${context.parsed.y.toFixed(2)}, 
                } else {
                  return ''; // Don't show any tooltip when no 'q' value exists
                }
              }
            }
          }
        }
      }
// });
    });
  }

function calculate() {
    
    let coordinatesInput = document.getElementById('coordinates').value;
    
    const formula = document.getElementById('formula').value;
    let diameter = parseFloat(document.getElementById('diameter').value)/1000;
    const totalHead = parseFloat(document.getElementById('totalHead').value)|| 60;


    const density = parseFloat(document.getElementById('density').value) || 1000; // é»˜è®¤ä¸ºæ°´çš„å¯†åº¦
    const viscosity = parseFloat(document.getElementById('viscosity').value) || 0.001; // é»˜è®¤ä¸ºæ°´çš„åŠ¨åŠ›ç²˜åº¦
   // const roughness = parseFloat(document.getElementById('roughness').value) /1000; // é»˜è®¤å€¼
    const cFactor = parseFloat(document.getElementById('cFactor').value) || 130; // é»˜è®¤Cç³»æ•°
  
    
    // è§£æåæ ‡è¾“å…¥
    const lines = coordinatesInput.trim().split('\n');
    if (lines.length < 2) {
        // æ•°æ®é•¿åº¦ä¸è¶³ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
        alert("ç®¡æ®µæ•°æ®ä¸è¶³ï¼Œè¯·ç¡®ä¿è¾“å…¥äº†è‡³å°‘2è¡Œçš„åæ ‡ä¿¡æ¯åé‡æ–°æäº¤ã€‚");
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        coordinatesInput.value = ""; // å‡è®¾coordinatesInputæ˜¯ä¸€ä¸ªDOMå…ƒç´ ï¼Œè¿™æ ·å¯ä»¥æ¸…ç©ºè¾“å…¥æ¡†
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
    }
    const nodes = lines.map(line => {
      const [x, y, z, q,k,D] = line.split(',').map(Number);
      
      return { x, y, z, q,k,D };
    });
    for(let i=1;i<nodes.length;i++){
        if (typeof nodes[i].x != 'number' || isNaN(nodes[i].x)) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„æ•°æ®[${nodes[i].x}]é”™è¯¯ï¼Œè¯·ç¡®ä¿æ¯è¡Œè¾“å…¥äº†è‡³å°‘6åˆ—ï¼ˆåæ ‡ x,y,zï¼ˆmï¼‰, æœ«ç«¯å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        }   
        if (typeof nodes[i].y != 'number' || isNaN(nodes[i].y)) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„æ•°æ®[${nodes[i].y}]é”™è¯¯ï¼Œè¯·ç¡®ä¿æ¯è¡Œè¾“å…¥äº†è‡³å°‘6åˆ—ï¼ˆåæ ‡ x,y,zï¼ˆmï¼‰, æœ«ç«¯å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        }  
        if (typeof nodes[i].z != 'number' || isNaN(nodes[i].z)) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„æ•°æ®[${nodes[i].z}]é”™è¯¯ï¼Œè¯·ç¡®ä¿æ¯è¡Œè¾“å…¥äº†è‡³å°‘6åˆ—ï¼ˆåæ ‡ x,y,zï¼ˆmï¼‰, æœ«ç«¯å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        }  
        if (typeof nodes[i].q != 'number' || isNaN(nodes[i].q)) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„æ•°æ®[${nodes[i].q}]é”™è¯¯ï¼Œè¯·ç¡®ä¿æ¯è¡Œè¾“å…¥äº†è‡³å°‘6åˆ—ï¼ˆåæ ‡ x,y,zï¼ˆmï¼‰, æœ«ç«¯å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        }  
        if (typeof nodes[i].k != 'number' || isNaN(nodes[i].k)) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„æ•°æ®[${nodes[i].k}]é”™è¯¯ï¼Œè¯·ç¡®ä¿æ¯è¡Œè¾“å…¥äº†è‡³å°‘6åˆ—ï¼ˆåæ ‡ x,y,zï¼ˆmï¼‰, æœ«ç«¯å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        
        // coordinatesInput.value = ""; // å‡è®¾coordinatesInputæ˜¯ä¸€ä¸ªDOMå…ƒç´ ï¼Œè¿™æ ·å¯ä»¥æ¸…ç©ºè¾“å…¥æ¡†
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        }  
        if (typeof nodes[i].D != 'number' || isNaN(nodes[i].D)) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„ç®¡å¾„æ•°æ®[${nodes[i].D}]é”™è¯¯ï¼Œè¯·ç¡®ä¿æ¯è¡Œè¾“å…¥äº†è‡³å°‘6åˆ—ï¼ˆåæ ‡ x,y,zï¼ˆmï¼‰, æœ«ç«¯å‡ºæµé‡ qï¼ˆmÂ³/hï¼‰, å±€éƒ¨æŸå¤±ç³»æ•° k, ç®¡æ®µç›´å¾„ d ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        // document.getElementById("coordinates").value = "";
        
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        } 
        if (nodes[i].D < 1) {
        // æ•°æ®é”™è¯¯ï¼Œæç¤ºç”¨æˆ·å¹¶æ¸…ç©ºæˆ–é‡æ–°è¯·æ±‚è¾“å…¥
            let msg = `ç®¡æ®µ ${i+1} çš„ç®¡å¾„æ•°æ®[${nodes[i].D}]é”™è¯¯ï¼Œç›´å¾„å¿…é¡»æ˜¯ d>1 ï¼ˆmmï¼‰ï¼‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚`;
            alert(msg);
        // å¦‚æœæœ‰é‡ç½®è¾“å…¥åŒºåŸŸçš„é€»è¾‘ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ï¼Œä¾‹å¦‚ï¼š
        // document.getElementById("coordinates").value = "";
        
        // æˆ–è€…è§¦å‘é‡æ–°è¾“å…¥çš„é€»è¾‘
        return; // ç»“æŸå½“å‰å‡½æ•°æ‰§è¡Œï¼Œé¿å…å¤„ç†ä¸å®Œæ•´æ•°æ®
        } 
    }
    
    // æ€»æµé‡è®¡ç®—
    let flowRate=0
    const nodeq=[]
    let q=0;
    for (let i = 0; i < nodes.length ; i++) {
      flowRate += nodes[i].q;
      q += nodes[i].q/3600
      nodeq.push(q)
    }

    flowRate=flowRate/3600;
    // è®¡ç®—æµé€Ÿ
    const crossSectionalArea = Math.PI * (diameter / 2) ** 2;
    const velocity = flowRate / crossSectionalArea;

    let headLoss=0;
    const pipeLength=[];
    const pipeLengths=[];
    const pipeHeadloss=[];
    const totalHeadlines=[];

    pipeLength.push(0);
    pipeLengths.push(0);

    let Lengths=0      
    for (let i = 0; i < nodes.length - 1; i++) {
      const dx = nodes[i + 1].x - nodes[i].x;
      const dy = nodes[i + 1].y - nodes[i].y;
      const dz = nodes[i + 1].z - nodes[i].z;
      Length = Math.sqrt(dx * dx + dy * dy + dz * dz);
      Lengths += Length
      pipeLength.push(Length);
      pipeLengths.push(Lengths);

      // pipeLength[i]=Length;
      // è®¡ç®—æµé€Ÿ
    }

    //if (formula === 'darcy-weisbach') {
   
        // é›·è¯ºæ•°
        //const reynoldsNumber = (density * velocity * diameter) / viscosity;
        
        //frictionFactor=calculateFrictionFactor(roughness, diameter, reynoldsNumber)
        //headLoss = calculateDarcyWeisbach(frictionFactor, Lengths, diameter, velocity);

    //} else if (formula === 'hazen-williams') {


      // ä½¿ç”¨å“ˆæ£®-å¨å»‰å§†æ–¯å…¬å¼è®¡ç®—æ°´å¤´æŸå¤±  10.67 * Math.pow(Q, 1.852) * Math.pow(C, -1.852) * Math.pow(D, -4.87) * L;
      headLoss = 10.67  * Math.pow(flowRate, 1.852) * Math.pow(cFactor, -1.852) * Math.pow(diameter, -4.87) * Lengths;
   //}
   flowRate=flowRate*3600;
   diameter=diameter*1000;

    // æ˜¾ç¤ºç»“æœ 
    const resultElement = document.getElementById('result');
    resultElement.innerHTML = `<br/>å…¨ç¨‹ç®¡é“æ€»é•¿åº¦: ${Lengths.toFixed(2)} m<br/>`;
    resultElement.innerHTML += `ç”¨æ’å®šæµé‡è®¡ç®—çš„æ€»æ°´å¤´æŸå¤±: ${headLoss.toFixed(2)} m<br/>`;
    resultElement.innerHTML += `å‡å®šç®¡é“ä¸å˜çš„ç›´å¾„: ${diameter.toFixed(2)} mm<br/>`;
    resultElement.innerHTML += `è®¡ç®—ç”¨æ€»æµé‡: ${flowRate.toFixed(2)} mÂ³/h<br/>`;
    resultElement.innerHTML += `æœ€å¤§æ€»æµé‡çš„ç®¡é“æµé€Ÿ: ${velocity.toFixed(2)} m/s<br/>`;
        // æ¸…é™¤ä¹‹å‰çš„ç®¡é“æ¨¡å‹
    // while (scene.children.length > 3) { // ä¿ç•™åæ ‡è½´
    //   scene.remove(scene.children[3]);
    // }
    // åˆ†æ®µç®¡é•¿åº¦
    
  

    pipeHeadloss.push(0);

    let sumheads=totalHead+ nodes[0].z;
    //console.log(sumheads);
    totalHeadlines.push(sumheads);

    //let dz;
    let head=0;
    // let sumhead=0;
    flowRate=flowRate/3600;
    console.log("Q="+flowRate);

    flowRate -=nodeq[0]
    for (let i = 0; i < nodes.length -1; i++) {
      pipediameter=nodes[i+1].D/1000
      const pipeCrossSectionalArea = Math.PI * (pipediameter / 2) ** 2;
      const pipeVelocity = (flowRate )/ pipeCrossSectionalArea;
      // é›·è¯ºæ•°
      const reynoldsNumber = (density * pipeVelocity * pipediameter) / viscosity;
      
      let frictionFactor=calculateFrictionFactor(roughness, pipediameter, reynoldsNumber)
      //å±€éƒ¨æ°´å¤´æŸå¤±
      let hk=nodes[i+1].k*pipeVelocity*pipeVelocity/(2*gravity);
        
      //dz = nodes[i].z - nodes[i-1].z;
        
      //if (formula === 'darcy-weisbach') {
    

       // console.log(frictionFactor);
       // headLoss = calculateDarcyWeisbach(frictionFactor, pipeLength[i+1], pipediameter, pipeVelocity);
       // console.log(headLoss);
        

      //} 
      if (formula === 'hazen-williams') {

          // const pipeCrossSectionalArea = Math.PI * (diameter / 2) ** 2;
          //console.log(pipeLength[i+1]);
          //console.log(flowRate);
          //console.log(cFactor);
          //console.log(pipediameter);
          
        // ä½¿ç”¨å“ˆæ£®-å¨å»‰å§†æ–¯å…¬å¼è®¡ç®—æ°´å¤´æŸå¤±  10.67 * Math.pow(Q, 1.852) * Math.pow(C, -1.852) * Math.pow(D, -4.87) * L;
          headLoss = 10.67  * Math.pow((flowRate ), 1.852) * Math.pow(cFactor, -1.852) * Math.pow(pipediameter, -4.87) * pipeLength[i+1];
          //console.log(headLoss);
        }
        // sprinkler-irrigation
       
      if (formula === 'sprinkler-irrigation') {
          
        let rness = roughness * 1000;
        switch (rness) {
          case 0.013:
                f = 1.312 * 1e6; // 1e6 æ˜¯ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º 1,000,000
                m = 2;
                b = 5.33;
              break;
          // å¦‚æœæœ‰å…¶ä»–caseï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šçš„caseåˆ†æ”¯
          case 0.014:
                f = 1.516 * 1e6; // 1e6 æ˜¯ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º 1,000,000
                m = 2;
                b = 5.33;
              break;
            case 0.015:
                f = 1.749 * 1e6; // 1e6 æ˜¯ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º 1,000,000
                m = 2;
                b = 5.33;
              break;
          default:
              // è¿™é‡Œå¤„ç† default çš„æƒ…å†µï¼Œå¦‚æœéœ€è¦çš„è¯
              f = 0.948 * 1e5; // 
              m = 1.77;
              b = 4.77;
              break;
        }
        l = pipeLength[i+1]
        flowq= flowRate;
        flowq=flowq*3600;
        d=pipediameter;
        d = d*1000; //æ¢ç®—æˆ mm
        headLoss = f*l *Math.pow( flowq,m)  / Math.pow( d, b);

      }
      if (formula === 'micro-irrigation') {
        
        const reynoldsNumber = (density * pipeVelocity * pipediameter) / viscosity;
        var d = pipediameter ; //document.calcarea2.diameter.value;
        
        var l = pipeLength[i+1]; //document.calcarea2.commentl.value;
        var flowq = flowRate; //document.calcarea2.commentq.value;
        flowq=flowq*1000*3600; // æ¢ç®—åˆ° l/h
        d = d*1000; //æ¢ç®—æˆ mm
        if (d<=8){
          if(reynoldsNumber<=2300){
            f=1.750;
            m=1.00;
            b=4.00;

          }else{
            f=0.595;
            m=1.69;
            b=4.69;

          }
        }else{
          f=0.505;
          m=1.75;
          b=4.75;
        }
        headLoss = f*l *Math.pow( flowq,m)  / Math.pow( d, b);
              
      }
      
      hf=headLoss+hk;
      pipeHeadloss.push(hf);
      head = hf; //+dz;
      sumheads -=head; 
      totalHeadlines.push(sumheads);
      flowRate -=nodeq[i]

      //console.log(`ç¬¬ ${i+1} æ®µçš„ hk æŸå¤±ä¸ºï¼š${hk.toFixed(3)} m`);
      //console.log(`ç¬¬ ${i+1} æ®µçš„ hf æŸå¤±ä¸ºï¼š${headLoss.toFixed(3)} m`);

      //console.log(`ç¬¬ ${i+1} æ®µçš„æ°´å¤´æŸå¤±ä¸ºï¼š${hf.toFixed(3)} m`);
      //console.log(`ç¬¬ ${i} èŠ‚ç‚¹çš„æ°´å¤´ä¸ºï¼š${sumheads.toFixed(3)} m`);
      //lengths +=l;
      //pipeLengths.push(lengths);

    }




    const resultPipeElement = document.getElementById('piperesult');
    resultPipeElement.innerHTML =`æ¯æ¡ç®¡æ®µï¼š<br/>`;
    for (let i = 0; i < nodes.length - 1; i++) {
      resultPipeElement.innerHTML += `ç®¡æ®µé•¿: ${ pipeLength[i+1].toFixed(2)} m<br/>`;
      resultPipeElement.innerHTML += ` ${i+1} ç®¡æ®µç®¡å¾„: ${ nodes[i+1].D.toFixed(2)} mm<br/>`;
      resultPipeElement.innerHTML += ` ${i+1} ç®¡æ®µæ°´å¤´æŸå¤±: ${ (pipeHeadloss[i+1]).toFixed(3)} m<br/>`;  //-nodes[i+1].z
    }

    const resultHeadlossElement = document.getElementById('headlossresult');
    resultHeadlossElement.innerHTML =`<br/>æ€»æ°´å¤´çº¿ï¼š<br/>`;
    for (let i = 0; i < nodes.length ; i++) {
      resultHeadlossElement.innerHTML += `èŠ‚ç‚¹ ${i} é«˜ç¨‹ ï¼š  ${ nodes[i].z.toFixed(3)} m<br/>`;
      resultHeadlossElement.innerHTML += `èŠ‚ç‚¹ ${i} æ°´å¤´ ï¼š  ${ totalHeadlines[i].toFixed(3)} m<br/>`;
      resultHeadlossElement.innerHTML += `èŠ‚ç‚¹ ${i} çš„å‡ºæµé‡  ï¼š  ${ nodes[i].q.toFixed(2)} mÂ³/h<br/>`;
    }

    
    // è®¡ç®—æ€»é•¿åº¦
    let totalLength = 0;
    for (let i = 0; i < nodes.length - 1; i++) {

      const dx = nodes[i + 1].x - nodes[i].x;
      const dy = nodes[i + 1].y - nodes[i].y;
      const dz = nodes[i + 1].z - nodes[i].z;
      totalLength += Math.sqrt(dx * dx + dy * dy + dz * dz);
      
    }
  
    // æ ¹æ®å…¬å¼è®¡ç®—æ°´å¤´æŸå¤±

    
     // æ›´æ–°å›¾è¡¨ pipeHeadloss
     updateChart(nodes, pipeHeadloss,   pipeLengths) ;
     calculateAndPlot(pipeLengths, totalHeadlines,nodes);
     plotPipeline(nodes);  //pipeLengths,pipeHeadloss,
  }



</script>
</body>
</html>